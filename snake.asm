
use16						; 16-битная адресация
	org	0x7C00  			; наша программа загружается по адресу 0x7C00

;-----------------------------------------------------------------------------
; общая инициализация 
;-----------------------------------------------------------------------------

start:
	cli						; запрещаем прерывания	
	xor ax,ax
    mov ds, ax 				; устанавливаем сегмент данных 
    mov sp, start 			; устанавливаем вершину стека (стек растет вниз)
    mov ss, ax 				; устанавливаем сегмент стека
    mov es, ax				; устанавливаем сегмент доп данных
    sti						; разрешаем прерывания	
  	cld						; направление движения строковых инструкций    

;-----------------------------------------------------------------------------
; загрузка сегментов кода  
;-----------------------------------------------------------------------------

load:

	mov ah, 02h    			; чтение секторов
;	mov dl, 0      			; номер диск (А !!!!!!!!!!!!!!!!!!!!!!)

	mov dh, 0      			; номер головки
	mov ch, 0      			; номер цилиндра
	mov cl, 2      			; номер сектора с которого начинаем читать (512 сектор)
	mov al, 8      			; число секторов 
	mov bx, 0x7E00 			; куда писать (0x7C00 + 512 = конец загруженной части)
	int 13h    

							; если ошибка cf = 1  (jc) 
	jnc 0x7E00     			; прыгаем на загруженный код

.error:
	mov si, error
	call writeMsg
	jmp reboot
;   	mov ah,	00h				; ah 00h установить видео режим, очистить экран
;   	mov	al,	03h				; al 03h текстовый режим 80x25
;   	int 0x10	

; 	mov ah, 0Eh      		; писать символ на активную видео страницу

;   	mov si, error         	; выводимое сообщение

; .writeError:
; 	lodsb					; al - символ из si, si+1
; 	test al, al				; проверяем не равен ли al 0
; 	je .endWriteError		; если равен, значит мы достигли конца файла
; 	int 10h					; выводим на экран символ al 
; 	jmp .writeError

; .endWriteError:
; 							; ожиданем нажатие клавиши 
; 	xor ax, ax				; ah = 00h читать (ожидать) следующую нажатую клавишу
; 	int 16h

;-----------------------------------------------------------------------------
; вывод текстового сообщения в режиме 03h + ожидание нажатия клавиши
;-----------------------------------------------------------------------------

writeMsg:

  	mov ah,	00h				; ah 00h установить видео режим, очистить экран
  	mov	al,	03h				; al 03h текстовый режим 80x25
  	int 0x10	

	mov ah, 0Eh      		; писать символ на активную видео страницу

.writeMsg:
	lodsb					; al - символ из si, si+1
	test al, al				; проверяем не равен ли al 0
	je .endWriteMsg		; если равен, значит мы достигли конца файла
	int 10h					; выводим на экран символ al 
	jmp .writeMsg

.endWriteMsg:
	
	mov ah, 02h
	mov bh, 0
	mov dh, 25
	mov dl, 0
	int 10h



							; ожиданем нажатие клавиши 
	xor ax, ax				; ah = 00h читать (ожидать) следующую нажатую клавишу
	int 16h

	ret
;-----------------------------------------------------------------------------
; перезагружаем компьютер
;-----------------------------------------------------------------------------

reboot:

	mov al,0FEh				; аппаратный сброс (отключение) процессора
	out 64h,al

	hlt						; ожидаем сброса процессора
	jmp $-1

;-----------------------------------------------------------------------------
; установка режима 12h (640x480x16) видеоадаптера + установка регистра es
;-----------------------------------------------------------------------------

setDisplayMode:

	mov ah, 00h    			; задаем режим работы видеоадаптера
	mov al, 12h    			; 640X480 16bit
	int 10h	
	push 0A000h	   			; es смещение на адрес видео памяти
	pop es
	ret

;-----------------------------------------------------------------------------
; проверяем нажата ли клавиша, и какая нажата
; возвращает в bx номер их массива key нажатой клавиши или -1 ели не нашел 
;																	подходящей
;-----------------------------------------------------------------------------

isKey:

    mov bx, -1 				; не нашли нужной клавиши

							; проверим есть ли символ в буфере клавиатуры
	mov ah, 01h	   			; ZF = 1 если символ не готов. ZF = 0 если символ готов.
    int 16h        			; AL = ASCII символ (если AL=0, AH содержит расширенный код ASCII )
            				; AH = сканкод  или расширенный код ASCII
    jz .end 				; если буфер пуст переходим в .end

.nextKey:					; проверяем весь буфер клавиатуры
							; и выбираем последнюю подходяшую клавишу

							; достанем символ из очереди
	mov ah, 00h    			; читать (ожидать) следующую нажатую клавишу
	int 16h        			; AL = ASCII символ (если AL=0, AH содержит расширенный код ASCII )
            				; AH = сканкод  или расширенный код ASCII, символ удаляется из очереди

    cmp ah, BYTE[ndirection]; проверяем не нажата ли запрещенная клавиша
    je .nochange			; чтобы не развернуть змейку на 180
    
    mov si, key
	mov cx, keyl			
.scas:						; проверим подходит ли нам клавиша (проверяем с массивом сканкодов)
	mov bp, cx 				
							; сравниваем нажатую клавишу с символом из массива
	cmp ah, BYTE [ds:si + bp -1] 
	je .change 				; если совпали то переходим в .change
	loop .scas
	jmp .nochange
.change:	
	mov bx, cx
	cmp cx, 5   			; если нажат пробел
	je .end
	cmp cx, 6 				; если нажат esc
	je .end
.nochange:	
	mov ah, 01h 			; проверяем, есть ли еще клавиши
	int 16h
	jnz .nextKey
    
.end:
	ret
;-----------------------------------------------------------------------------
; пауза
;-----------------------------------------------------------------------------

delay:

.save:
	mov ah, 0      			; чтение часов
	int 1Ah        			; CX,DX = счетчик тиков с момента сброса. CX - старшая часть значения.
; 1 с = 18.2		
	add dx, WORD[delayStep]
	mov WORD [time], dx 	; сохраняем нужное время
.compare:
	int 1Ah        			; получаем значение счетчика
	cmp dx, WORD [time] 	; сравним с нужным
	jae .ok	       
	jmp .compare
.ok:
	ret						; возвращаемся

;-----------------------------------------------------------------------------
; рисуем в di фигуру 8x8 из si
;-----------------------------------------------------------------------------

drawPixel:

	pusha 

	mov dx, 03CEh			; порт видеокарты
	mov cx, 8 				; 8 строк

							; цикл 8 на 8 
.forLine:					; цикл по строкам
	mov bl, 0x80 			; самый левый бит в 1

	push cx 				; сохраняем cx цикла по строкам
	mov cx, 8 				

.forColum:					; вложенный цикл для столбцов
	lodsb					; загружаем цвет пикселя из si в al, si++

	shl ax, 8 				; ah = al(цвет), al = 00h - регистр установки/сброса (устанавливаем цвет)
	out dx, ax 
	mov ah, bl 				; bl - битовая маска (нужный нам пиксель)
	mov al, 8 				; al = 08h - регистр битовой маски
	out dx, ax 				
	mov al, BYTE[es:di] 	; заполнили регистры-защелки
	mov BYTE[es:di], al 	; вывели на экран
							; выведится наш бит bl(который установили в регистр битовой маски), цвет соответствует
							; регистру установки сброса. Остальные биты берутся из защелки, тоесть не изменяются 

	shr bl, 1 				; переходим к следующему пикселю
	loop .forColum

	pop cx 					; достаем cx
	add di,	80 				; переходим к следующей строке
	loop .forLine

	popa

	ret

;-----------------------------------------------------------------------------
; проверяем di на наличие фигуры 
;-----------------------------------------------------------------------------

collision:

	push si           		
	xor ax,ax
	mov si, ring 			; si на  начало кольца
.for:
	cmp BYTE[ds:si+2], 255  ; если элемент свободен - проходим мимо
	je .next 
	cmp WORD[ds:si], di     ; если элемент равен di значит он занят
	jne .next
	mov ax, 1 			 	; возвращаем 1
.next:	
	add si, 3 				; переходим к следующему жлементу
	cmp si, endring 		; пока не достигнем конца кольца=)
	jne .for

	pop si
	ret

;-----------------------------------------------------------------------------
; инициализируем генератор случайных чисел
;-----------------------------------------------------------------------------

randominit:
	push dx

	mov dx, 43h				; порт таймера (управляющий регистр)
	mov al, 10110110b 		; второй канал, чтение/запись младшего
							; затем старшего байта, режим 3 (генератор 
							; прямоугольных импульсов) 	
	out dx, al     			; программируем таймер
	mov dx, 42h 			; порт канала 2
	mov ax, 1000 			; значение счетчика
	out dx, al 				; устанавливаем (младшая часть)
	mov al, ah    
	out dx, al 				; потом старшая

	pop dx

	ret

;-----------------------------------------------------------------------------
; генерация случайного числа
;-----------------------------------------------------------------------------

random:

	rdtsc

	push dx
	push bx

	; mov dx, 43h				; порт таймера (управляющий регистр)
	; mov al, 10000110b			; зафиксировать текущее состояние счетчика
	; 							; для чтения
	; out dx, al

	; mov dx, 42h 				; читаем состояние счетчика
	; in al, dx
	; mov bl, al
	; in al, dx
	; mov ah, al
	; mov al, bl

	
	rdtsc
	pop bx
	pop dx

	ret

;-----------------------------------------------------------------------------
; сажаем на карту яблоко
;-----------------------------------------------------------------------------

setApple:

	push di
.firstApple:
	call random
	mov dx, 0
	div WORD[line]
	mov ax, dx
	mul WORD[coll]
	mov di, ax
	call random
	mov dx, 0
	div WORD[col]
	add di, dx

	call collision
	cmp ax, 0
	jne .firstApple

	mov si, apple
	call drawPixel

    mov WORD[applexy],di

	pop di

	ret

; сообщение при ошибки загрузки кода	
error:		db 'Error in function load: code not loaded!',10,13,0
lostmsg:	times 13 db 10  
			times 34 db ' ' 
			db 'You lost =(',10,13,0
; забиваем до таблицы разделов ноликами
endmbr: 	times 0x1BE-endmbr+start+1 db 0
; пишем таблицу разделов (для моей флешки)
;startptr:	db 0x01,0x01,0x00,0x0C,0xFE,0xFF,0xB3,0x3F,0x00,0x00,0x00,0x41,0x8D,0xE8
; оставшееся место забиваем нулями
endptr:     times 0x01FE-endptr+start db 0
; сигнатура загрузочного сектора
			db 0x55, 0xAA 

;-----------------------------------------------------------------------------
; часть которая будет загружена 
;-----------------------------------------------------------------------------			

uploadedCode:

	cld 

	call setDisplayMode 	; установили графический режим

; настраиваем видеокарту для вывода цветных пикселей =)

	mov dx, 03CEh			; порт видеокарты
	mov ax, 0F01h 			; ah = F,al = 01h - регистр разрешения установки/сброса
	out dx, ax				; разрешаем установку/сброс для всех плоскостей

	call randominit

	mov di, 0
	mov si, egg
	call drawPixel

	call setApple
	
.test:
	call delay
	call isKey
	cmp bx, -1 				; нашли ли символ
	je .lastKey
	cmp bx, 4 				; если нажат пробел или esc
	ja .noChange
	mov BYTE[direction],bl  ; сохранили направление
	mov al, BYTE[nkey+bx-1] ; al - обратная клавиша (вверх - вниз,влево - вправо)
	mov BYTE[ndirection],al ; сохранили запрещеное направление
	jmp .lastKey 			; направление изменено, обрабатываем
.noChange:	
	cmp bx, 6 				; если нажата клавиша esc
; TODO сделать вывод сообщения о перезагрузке
	je reboot 				; перезагружаемся
; TODO сделать вывод сообщения о паузе
.wait: 						; если нажат пробел - пауза
	call isKey 		 		; опрашиваем клавиатуру

	cmp bx, 6 				; если esc - ребутимся
	je reboot

	cmp bx, 5 				; если пробел - убираем паузу
	je .lastKey

	jmp .wait	

.lastKey:
	cmp BYTE[direction], 0 	; первый запуск если не выбрано направление (ни разу не нажимались стрелочки)
	je .next

	cmp BYTE[first], 1 		; первый запуск, заносим яйцо в стек с направлением головы змеи
	jne .cont

	mov si, first
	mov BYTE[si], 0 		; чтобы больше сюда не попадать

	mov si, WORD [head] 	; голова в кольце
	mov WORD[ds:si],di 		; записываем туда координаты нашего элемента
	mov bl, BYTE[direction]
	mov BYTE[ds:si+2],bl  	; направление
	add si,3 				; увеличиваем указатель на голову
	mov WORD[head], si 		; сохраняем

.cont:
	xor bx, bx
	mov bl, BYTE[direction]
	call reDrawSnake
.next:	
	jmp .test
	jmp $

;-----------------------------------------------------------------------------
; перересовываем змею
; bx - 1..4 
;-----------------------------------------------------------------------------			

reDrawSnake:

	cmp BYTE[nodel], 0
	jne .decdel

	push di 				; сохраняем di
	mov si, WORD[tail] 		; указатель на хвост 
	mov di, WORD[ds:si] 	; координаты хвоста
	mov si, black 			; закрашиваем черным квадратом
	call drawPixel

	mov si, WORD[tail]  	; указатель на хвост 
	mov BYTE[ds:si+2], 255  ; освобождаем жлемент 
	add si, 3 				; переходим к следующему элементу 
	cmp si, endring			; если указатель в конце ring
	jne .cont3
	mov si, ring 			; перемещаю его в начало	
.cont3:
	xor ax, ax      		
	mov di, WORD[ds:si] 	; загружаем координаты нового хвоста
	mov al, BYTE[ds:si+2]  	; его направление
	
	mov WORD[tail], si 		; сохранили указатель на новый хвост

	mov bp, ax 				; формируем смещение на форму хвоста
	add bp, bp
	mov si, [tails+bp-2] 	; tails + ax * 2 - 2
	call drawPixel 			; рисуем новый хвост
	pop di

	jmp .cont2
.decdel:
	mov al, BYTE[nodel] 	; уменьшаем количество нестираемых частей
	dec al
	mov BYTE[nodel], al

.cont2:
;-----------------------------------------------------------------------------			
; голова
;-----------------------------------------------------------------------------			
	xor ax, ax
	mov si, WORD [head] 	; загружаем указатель на голову

	cmp si, ring 			; если указатель в начале кольца
	jne .cont1 
	mov si, endring 		; смещаем его в конец
.cont1:
	mov al, BYTE [ds:si-1] 	; получаем направление текущей головы
	mov BYTE [ds:si-1], bl  ; и заменяем его на направление текущей (требуется для правильной отрисовки хвоста)

	dec al 					; формируем смещение для таблицы фигур
	mov bp, 8   			; первое в al номер столбца
	mul bp					; поэтому ( al - 1 ) * 8 (4 элемента в строке по 2 байта)
	mov bp, ax 				; сохранили в bp

	xor ax, ax 		
	mov al, bl 				; bl - номер столбца
	dec al 					; просто ( bl - 1 ) * 2 
	add al, al
	add bp, ax 				; bp - смещение в таблице фигур
	mov si, WORD[table + bp]; загружаем нужную фигуру и рисуем ее
	call drawPixel

	push bx  				; сохраним направление 

	mov ax, di
	mov dx, 0
	div WORD[coll]			; ax - номер строки, dx - номер столбца
	add bx,bx 				; смещение нужно 2 байтное
	mov si, WORD[heads + bx - 2]
	add ax, WORD[offset + bx - 2]	; новый y
	add dx, WORD[offset + bx - 2 + 8] ; новый x
	mov bx, dx 				; сохранили x

							; ax = y
	add ax, 60 				; y = y + 60
	xor dx, dx
	div WORD[line]			; y = y % 60
	mov ax, dx
	mul WORD[coll] 			; y = y * 640

	mov di, ax				


	mov ax, bx 				; ax = x
	add ax, 80 				; x = x + 80
	xor dx, dx
	div WORD[col]       	; x = x % 80

	add di, dx 				; новый адрес
	pop bx
 
 	call collision 			; проверяем не ударились ли мы
 	cmp ax, 0 		
 	jne lost  				; если да ребутимся

	push si	
	mov si, WORD[head]		; голова в кольце
	mov WORD[ds:si],di 		; записываем туда координаты нашего элемента
	mov BYTE[ds:si+2],bl  	; направление
	add si,3 				; увеличиваем указатель на голову

	cmp si, endring			; если указатель в конце ring
	jne .cont
	mov si, ring 			; перемещаю его в начало
.cont:	
	mov WORD[head], si 		; сохраняем	

	pop si

	call drawPixel


 	cmp di, WORD[applexy]   ; проверяем словили ли яблоко
 	jne .noApple
 	call setApple
 	mov al, BYTE[delayStep] ; увеличиваем скорость
 	dec al
 	cmp al, 0 			 	; если дошли до макса - перезагружаемся
 	je win
 	mov BYTE[delayStep], al ; неудаляем один раз хвост (увеличиваем размер змеи)
 	mov al, BYTE[nodel]
 	inc al
 	mov BYTE[nodel], al
.noApple:
	ret

lost:
  	mov si, lostmsg         	; выводимое сообщение
  	call writeMsg
	jmp reboot

win:
  	mov si, winmsg         	; выводимое сообщение
  	call writeMsg
	jmp reboot


winmsg:		times 13 db 10  
			times 36 db ' ' 
			db 'You win!',10,13,0

applexy:	dw 0
; первый запуск
first:		db 1
; не удалять хвост
nodel:		db 5
; количество линей в строчке нашей ск	
coll:		dw 640	
; количество колонок в нашей системе координат
col:		dw 80
; количество строк в нашей системе координат
line: 		dw 60
; переменная для таймера
time:		dw 0
; шаг таймера (18 - секунда)
delayStep:	dw 5
; смещения для рисования головы
; 0..3 - для строк, 4..7 - для столбцов
offset:		dw -1,0,1,0,0,1,0,-1
; направление движения змеи
; 1 - вверх
; 2 - вправо
; 3 - вниз
; 4 - влево
direction:	db 0

; запрещеное направление движения змеи
; чтобы змея не могла развернуться на 180 и уйти в себя=)
ndirection:	db 0

; список клавиш и соответствующие смещения
; верх,право, низ, лево,
nkey:		db 50h,4Bh,48h,4Dh
key:		db 48h,4Dh,50h,4Bh,39h,01h
keyl:		equ $-key 
heads:		dw headup,headright,headdown,headleft
tails:		dw tailup,tailright,taildown,tailleft
table: 		dw bodyv,bodydr,0,bodydl,bodyul,bodyh,bodydl,0,0,bodyur,bodyv,bodyul,bodyur,0,bodydr,bodyh
black:		TIMES 64 db 0
headright:	db  0,14,14,14, 0, 0, 0, 0,14,14,14,14,14, 0, 0, 0, 3,14,14, 0,14,14, 0, 0,14, 3,14,14,14,14,14,14,14, 3,14,14,14,14,14,14, 3,14,14, 0,14,14, 0, 0,14,14,14,14,14, 0, 0, 0, 0,14,14,14, 0, 0, 0, 0
headdown:	db  0,14, 3,14,14, 3,14, 0,14,14,14, 3, 3,14,14,14,14,14,14,14,14,14,14,14,14,14, 0,14,14, 0,14,14, 0,14,14,14,14,14,14, 0, 0, 0,14,14,14,14, 0, 0, 0, 0, 0,14,14, 0, 0, 0, 0, 0, 0,14,14, 0, 0, 0
headup:		db  0, 0, 0,14,14, 0, 0, 0, 0, 0, 0,14,14, 0, 0, 0,	0, 0,14,14,14,14, 0, 0,	0,14,14,14,14,14,14, 0,14,14, 0,14,14, 0,14,14,14,14,14,14,14,14,14,14,14,14,14, 3, 3,14,14,14, 0,14, 3,14,14, 3,14, 0
headleft:	db  0, 0, 0, 0,14,14,14, 0,	0, 0, 0,14,14,14,14,14,	0, 0,14,14, 0,14,14, 3,14,14,14,14,14,14, 3,14,14,14,14,14,14,14, 3,14, 0, 0,14,14, 0,14,14, 3, 0, 0, 0,14,14,14,14,14, 0, 0, 0, 0,14,14,14, 0
bodyh:		db  0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,14,14,14,14,	3,14,14, 3, 3,14,14, 3,14, 3, 3,14,14, 3, 3,14,14, 3, 3,14,14, 3, 3,14, 3,14,14, 3, 3,14,14, 3,14,14,14,14,14,14,14,14, 0, 0, 0, 0, 0, 0, 0, 0
bodyv:		db  0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0
bodyul:		db  0,14, 3,14,14, 3,14, 0,14,14,14, 3, 3,14,14, 0, 3,14, 3,14,14, 3,14, 0,14, 3,14,14,14, 3,14, 0,14, 3,14,14, 3,14,14, 0, 3,14, 3, 3,14,14,14, 0,14,14,14,14,14,14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
bodyur:		db  0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14,14, 0,14, 3,14,14, 3,14, 3, 0,14, 3,14,14,14, 3,14, 0,14,14, 3,14,14, 3,14, 0,14,14,14, 3, 3,14, 3, 0, 0,14,14,14,14,14,14, 0, 0, 0, 0, 0, 0, 0, 0
bodydl:	 	db  0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,14,14, 0, 0, 3,14, 3, 3,14,14,14, 0,14, 3,14,14, 3,14,14, 0,14, 3,14,14,14, 3,14, 0, 3,14, 3,14,14, 3,14, 0,14,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0
bodydr:		db  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,14,14, 0,14,14,14, 3, 3,14, 3, 0,14,14, 3,14,14, 3,14, 0,14, 3,14,14,14, 3,14, 0,14, 3,14,14, 3,14, 3, 0,14,14, 3, 3,14,14,14, 0,14, 3,14,14, 3,14, 0
tailright: 	db  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,14,14, 0,14,14, 3, 3,14,14, 3,14,14, 3,14,14, 3, 3,14,14,14, 3,14,14, 3, 3,14, 0,14,14, 3, 3,14,14, 3, 0, 0,14,14,14,14,14,14,	0, 0, 0, 0, 0, 0, 0, 0
tailleft:   db  0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,14,14, 0, 0, 3,14,14, 3, 3,14,14, 0,14, 3, 3,14,14, 3,14,14,14, 3, 3,14,14, 3,14,14, 3,14,14, 3, 3,14,14, 0,14,14,14,14,14,14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
tailup:	    db  0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14, 0, 0, 0,14,14,14,14, 0, 0, 0, 0, 0,14,14, 0, 0, 0
taildown:	db  0, 0, 0,14,14, 0, 0, 0, 0, 0,14,14,14,14, 0, 0, 0,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14, 3,14,14, 3,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14,14, 3, 3,14,14, 0, 0,14, 3,14,14, 3,14, 0
apple:		db  0, 0, 0, 0, 2, 0, 0, 0, 0,12,12, 2, 0,12,12, 0,12,12,12,12,12,12,12, 4,12,15,12,12,12,12, 4, 4,12,15,12,12,12,12, 4, 4,12,12,12,12,12, 4, 4, 4, 0, 4,12,12, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0
egg:		db  0, 0, 0,15,15, 0, 0, 0, 0, 0,15,11,15,15, 0, 0, 0,15,11,15,15,15, 7, 0, 0,15,15,15,15,15, 7, 0,15,15,15,15,15,15, 7, 7,15,15,15,15,15, 7, 7, 7, 0,15,15, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 7, 0, 0
; указатель на хвост в кольце
tail:		dw ring
; указатель на голову в кольце
head:		dw ring
; кольцо, тут будут хранится координаты и направления частей змеи (коррдината в виде dw указателя на видеопамять, db направление как в direction)
; разчитано на змею длиной 20
ring:		TIMES 60 db 255
endring:
endprog:    times 0A00h-endprog+start db 0	